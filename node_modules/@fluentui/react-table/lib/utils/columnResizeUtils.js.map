{"version":3,"names":["DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columnDefinitionsToState","columns","state","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","idealWidth","minWidth","padding","_a","width","defaultWidth","_b","Math","max","length","find","col","getColumnById","c","getColumnByIndex","index","getTotalWidth","reduce","sum","getLength","getColumnWidth","setColumnProperty","localState","property","value","currentColumn","updatedColumn","newState","acc","current","adjustColumnWidthsToFitContainer","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"sources":["../src/packages/react-components/react-table/src/utils/columnResizeUtils.ts"],"sourcesContent":["import { TableColumnDefinition, ColumnWidthState, TableColumnId, TableColumnSizingOptions } from '../hooks';\n\nconst DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\n\nexport function columnDefinitionsToState<T>(\n  columns: TableColumnDefinition<T>[],\n  state: ColumnWidthState[] = [],\n  columnSizingOptions: TableColumnSizingOptions = {},\n): ColumnWidthState[] {\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n\n    if (existingColumnState) {\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding,\n      } = columnSizingOptions[column.columnId] ?? {};\n\n      if (\n        idealWidth !== existingColumnState.idealWidth ||\n        minWidth !== existingColumnState.minWidth ||\n        padding !== existingColumnState.padding\n      ) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding,\n        };\n      }\n      return existingColumnState;\n    }\n\n    const {\n      defaultWidth,\n      idealWidth = DEFAULT_WIDTH,\n      minWidth = DEFAULT_MIN_WIDTH,\n      padding,\n    } = columnSizingOptions[column.columnId] ?? {};\n\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth ?? idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth ?? idealWidth, minWidth),\n      padding: padding ?? 16,\n    };\n  });\n\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n\n    updated = true;\n  }\n\n  return updated ? updatedState : state;\n}\n\nexport function getColumnById(state: ColumnWidthState[], columnId: TableColumnId) {\n  return state.find(c => c.columnId === columnId);\n}\n\nexport function getColumnByIndex(state: ColumnWidthState[], index: number) {\n  return state[index];\n}\n\nexport function getTotalWidth(state: ColumnWidthState[]): number {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\n\nexport function getLength(state: ColumnWidthState[]) {\n  return state.length;\n}\n\nexport function getColumnWidth(state: ColumnWidthState[], columnId: TableColumnId): number {\n  const column = getColumnById(state, columnId);\n  return column?.width ?? 0;\n}\n\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(\n  localState: ColumnWidthState[],\n  columnId: TableColumnId,\n  property: keyof ColumnWidthState,\n  value: number,\n) {\n  const currentColumn = getColumnById(localState, columnId);\n\n  if (!currentColumn || currentColumn?.[property] === value) {\n    return localState;\n  }\n\n  const updatedColumn = { ...currentColumn, [property]: value };\n\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, [] as ColumnWidthState[]);\n\n  return newState;\n}\n\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state: ColumnWidthState[], containerWidth: number) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n\n      i++;\n    }\n  }\n\n  // The total width is larger than container, we need to squash the columns\n  else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n\n  return newState;\n}\n"],"mappings":"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"}