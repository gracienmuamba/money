"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDataGrid_unstable = void 0;
const React = /*#__PURE__*/require("react");
const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");
const useTable_1 = /*#__PURE__*/require("../Table/useTable");
const hooks_1 = /*#__PURE__*/require("../../hooks");
const TableSelectionCell_1 = /*#__PURE__*/require("../TableSelectionCell");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
const keyboard_keys_1 = /*#__PURE__*/require("@fluentui/keyboard-keys");
/**
 * Create the state required to render DataGrid.
 *
 * The returned state can be modified with hooks such as useDataGridStyles_unstable,
 * before being passed to renderDataGrid_unstable.
 *
 * @param props - props from this instance of DataGrid
 * @param ref - reference to root HTMLElement of DataGrid
 */
const useDataGrid_unstable = (props, ref) => {
  const {
    items,
    columns,
    focusMode = 'cell',
    selectionMode,
    onSortChange,
    onSelectionChange,
    defaultSortState,
    sortState,
    selectedItems,
    defaultSelectedItems,
    subtleSelection = false,
    selectionAppearance = 'brand',
    getRowId,
    resizableColumns,
    columnSizingOptions,
    onColumnResize
  } = props;
  const navigable = focusMode !== 'none';
  const keyboardNavAttr = react_tabster_1.useArrowNavigationGroup({
    axis: 'grid'
  });
  const tableState = hooks_1.useTableFeatures({
    items,
    columns,
    getRowId
  }, [hooks_1.useTableSort({
    defaultSortState,
    sortState,
    onSortChange
  }), hooks_1.useTableSelection({
    defaultSelectedItems,
    selectedItems,
    onSelectionChange,
    selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : 'multiselect'
  }), hooks_1.useTableColumnSizing_unstable({
    onColumnResize,
    columnSizingOptions,
    // The selection cell is not part of the columns, therefore its width needs to be subtracted
    // from the container to make sure the columns don't overflow the table.
    containerWidthOffset: selectionMode ? -TableSelectionCell_1.CELL_WIDTH : 0
  })]);
  const innerRef = React.useRef(null);
  const {
    findFirstFocusable,
    findLastFocusable
  } = react_tabster_1.useFocusFinders();
  const onKeyDown = react_utilities_1.useEventCallback(e => {
    var _a, _b, _c;
    (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
    if (!innerRef.current || !e.ctrlKey || e.defaultPrevented) {
      return;
    }
    if (e.key === keyboard_keys_1.Home) {
      const firstRow = innerRef.current.querySelector('[role="row"]');
      if (firstRow) {
        (_b = findFirstFocusable(firstRow)) === null || _b === void 0 ? void 0 : _b.focus();
      }
    }
    if (e.key === keyboard_keys_1.End) {
      const rows = innerRef.current.querySelectorAll('[role="row"]');
      if (rows.length) {
        const lastRow = rows.item(rows.length - 1);
        (_c = findLastFocusable(lastRow)) === null || _c === void 0 ? void 0 : _c.focus();
      }
    }
  });
  const baseTableState = useTable_1.useTable_unstable({
    role: 'grid',
    as: 'div',
    noNativeElements: true,
    ...(navigable && keyboardNavAttr),
    ...props,
    onKeyDown
  }, react_utilities_1.useMergedRefs(ref, tableState.tableRef, innerRef));
  return {
    ...baseTableState,
    focusMode,
    tableState,
    selectableRows: !!selectionMode,
    subtleSelection,
    selectionAppearance,
    resizableColumns
  };
};
exports.useDataGrid_unstable = useDataGrid_unstable;
//# sourceMappingURL=useDataGrid.js.map