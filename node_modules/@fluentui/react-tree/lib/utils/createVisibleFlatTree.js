import { flatTreeRootParentId } from './createUnfilteredFlatTree';
import { treeDataTypes } from './tokens';
/**
 * creates methods that depend on the unfilteredFlatTree and the current available openItems
 */
export function createVisibleFlatTree(unfilteredFlatTree, openItems) {
  let visibleItems = null;
  const getNextNavigableItem = data => {
    var _a, _b, _c, _d;
    const item = unfilteredFlatTree.itemsPerId.get(data.target.id);
    if (!item || !visibleItems) {
      return null;
    }
    switch (data.type) {
      case treeDataTypes.arrowLeft:
        return item.parentId ? (_a = unfilteredFlatTree.itemsPerId.get(item.parentId)) !== null && _a !== void 0 ? _a : null : null;
      case treeDataTypes.arrowRight:
        return (_b = visibleItems[item.index + 1]) !== null && _b !== void 0 ? _b : null;
      case treeDataTypes.end:
        return visibleItems[visibleItems.length - 1];
      case treeDataTypes.home:
        return visibleItems[0];
      case treeDataTypes.arrowDown:
        return (_c = visibleItems[item.index + 1]) !== null && _c !== void 0 ? _c : null;
      case treeDataTypes.arrowUp:
        return (_d = visibleItems[item.index - 1]) !== null && _d !== void 0 ? _d : null;
      default:
        return null;
    }
  };
  function* makeVisibleItemsGenerator() {
    var _a;
    visibleItems = [];
    for (let index = 0, visibleIndex = 0; index < unfilteredFlatTree.items.length; index++) {
      const item = unfilteredFlatTree.items[index];
      const parent = unfilteredFlatTree.itemsPerId.get((_a = item.parentId) !== null && _a !== void 0 ? _a : flatTreeRootParentId);
      if (!parent) {
        break;
      }
      if (isFlatTreeItemVisible(item, {
        openItems,
        unfilteredFlatTree
      })) {
        item.index = visibleIndex++;
        visibleItems.push({
          ...item
        });
        yield item;
      } else {
        index += parent.childrenSize - 1 + item.childrenSize;
      }
    }
  }
  return {
    getNextNavigableItem,
    items: () => {
      return visibleItems || makeVisibleItemsGenerator();
    }
  };
}
function isFlatTreeItemVisible(item, {
  openItems,
  unfilteredFlatTree: flatTree
}) {
  if (item.level === 1) {
    return true;
  }
  while (item.parentId && item.parentId !== flatTreeRootParentId) {
    if (!openItems.has(item.parentId)) {
      return false;
    }
    const parent = flatTree.itemsPerId.get(item.parentId);
    if (!parent) {
      return false;
    }
    item = parent;
  }
  return true;
}
//# sourceMappingURL=createVisibleFlatTree.js.map