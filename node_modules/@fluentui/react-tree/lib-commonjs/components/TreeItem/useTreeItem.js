"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTreeItem_unstable = void 0;
const React = /*#__PURE__*/require("react");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
const react_icons_1 = /*#__PURE__*/require("@fluentui/react-icons");
const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");
const react_utilities_2 = /*#__PURE__*/require("@fluentui/react-utilities");
const useTreeItemStyles_1 = /*#__PURE__*/require("./useTreeItemStyles");
const keyboard_keys_1 = /*#__PURE__*/require("@fluentui/keyboard-keys");
const react_utilities_3 = /*#__PURE__*/require("@fluentui/react-utilities");
const react_portal_1 = /*#__PURE__*/require("@fluentui/react-portal");
const index_1 = /*#__PURE__*/require("../../contexts/index");
const tokens_1 = /*#__PURE__*/require("../../utils/tokens");
/**
 * Create the state required to render TreeItem.
 *
 * The returned state can be modified with hooks such as useTreeItemStyles_unstable,
 * before being passed to renderTreeItem_unstable.
 *
 * @param props - props from this instance of TreeItem
 * @param ref - reference to root HTMLElement of TreeItem
 */
const useTreeItem_unstable = (props, ref) => {
  const [children, subtreeChildren] = React.Children.toArray(props.children);
  const contextLevel = index_1.useTreeContext_unstable(ctx => ctx.level);
  const {
    content,
    subtree,
    expandIcon,
    leaf: isLeaf = subtreeChildren === undefined,
    actions,
    as = 'div',
    onClick,
    onKeyDown,
    ['aria-level']: level = contextLevel,
    ...rest
  } = props;
  const requestOpenChange = index_1.useTreeContext_unstable(ctx => ctx.requestOpenChange);
  const requestNavigation = index_1.useTreeContext_unstable(ctx => ctx.requestNavigation);
  const id = react_utilities_1.useId('fui-TreeItem-', props.id);
  const isBranch = !isLeaf;
  const open = index_1.useTreeContext_unstable(ctx => isBranch && ctx.openItems.has(id));
  const {
    dir,
    targetDocument
  } = react_shared_contexts_1.useFluent_unstable();
  const expandIconRotation = open ? 90 : dir !== 'rtl' ? 0 : 180;
  const actionsRef = React.useRef(null);
  const expandIconRef = React.useRef(null);
  const subtreeRef = React.useRef(null);
  const handleArrowRight = event => {
    if (!open && isBranch) {
      return requestOpenChange({
        event,
        open: true,
        type: tokens_1.treeDataTypes.arrowRight,
        target: event.currentTarget
      });
    }
    if (open && isBranch) {
      return requestNavigation({
        event,
        type: tokens_1.treeDataTypes.arrowRight,
        target: event.currentTarget
      });
    }
  };
  const handleArrowLeft = event => {
    if (open && isBranch) {
      return requestOpenChange({
        event,
        open: false,
        type: tokens_1.treeDataTypes.arrowLeft,
        target: event.currentTarget
      });
    }
    if (!open && level > 1) {
      return requestNavigation({
        event,
        target: event.currentTarget,
        type: tokens_1.treeDataTypes.arrowLeft
      });
    }
  };
  const handleEnter = event => {
    requestOpenChange({
      event,
      open: isLeaf ? open : !open,
      type: tokens_1.treeDataTypes.enter,
      target: event.currentTarget
    });
  };
  const handleClick = react_utilities_2.useEventCallback(event => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    const isEventFromActions = actionsRef.current && react_portal_1.elementContains(actionsRef.current, event.target);
    if (isEventFromActions) {
      return;
    }
    const isEventFromSubtree = subtreeRef.current && react_portal_1.elementContains(subtreeRef.current, event.target);
    if (isEventFromSubtree) {
      return;
    }
    const isFromExpandIcon = expandIconRef.current && react_portal_1.elementContains(expandIconRef.current, event.target);
    requestOpenChange({
      event,
      open: isLeaf ? open : !open,
      type: isFromExpandIcon ? tokens_1.treeDataTypes.expandIconClick : tokens_1.treeDataTypes.click,
      target: event.currentTarget
    });
    requestNavigation({
      event,
      target: event.currentTarget,
      type: tokens_1.treeDataTypes.click
    });
  });
  const handleKeyDown = react_utilities_2.useEventCallback(event => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
    if (event.currentTarget !== event.target) {
      return;
    }
    if (event.isDefaultPrevented()) {
      return;
    }
    switch (event.key) {
      case keyboard_keys_1.Enter:
        return handleEnter(event);
      case keyboard_keys_1.ArrowRight:
        return handleArrowRight(event);
      case keyboard_keys_1.ArrowLeft:
        return handleArrowLeft(event);
      case keyboard_keys_1.End:
        return requestNavigation({
          event,
          type: tokens_1.treeDataTypes.end,
          target: event.currentTarget
        });
      case keyboard_keys_1.Home:
        return requestNavigation({
          event,
          type: tokens_1.treeDataTypes.home,
          target: event.currentTarget
        });
      case keyboard_keys_1.ArrowUp:
        return requestNavigation({
          event,
          type: tokens_1.treeDataTypes.arrowUp,
          target: event.currentTarget
        });
      case keyboard_keys_1.ArrowDown:
        return requestNavigation({
          event,
          type: tokens_1.treeDataTypes.arrowDown,
          target: event.currentTarget
        });
    }
    const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
    if (isTypeAheadCharacter) {
      return requestNavigation({
        event,
        target: event.currentTarget,
        type: tokens_1.treeDataTypes.typeAhead
      });
    }
  });
  const [isActionsVisible, setActionsVisible] = React.useState(false);
  const showActions = react_utilities_2.useEventCallback(event => {
    const isEventFromSubtree = subtreeRef.current && react_portal_1.elementContains(subtreeRef.current, event.target);
    if (!isEventFromSubtree) {
      setActionsVisible(true);
    }
  });
  const hideActions = react_utilities_2.useEventCallback(event => {
    const isEventFromSubtree = subtreeRef.current && react_portal_1.elementContains(subtreeRef.current, event.target);
    if (!isEventFromSubtree) {
      setActionsVisible(false);
    }
  });
  // Listens to focusout event on the document to ensure treeitem actions visibility on portal scenarios
  // TODO: find a better way to ensure this behavior
  React.useEffect(() => {
    if (actionsRef.current) {
      const handleFocusOut = event => {
        setActionsVisible(react_portal_1.elementContains(actionsRef.current, event.relatedTarget));
      };
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('focusout', handleFocusOut, {
        passive: true
      });
      return () => {
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('focusout', handleFocusOut);
      };
    }
  }, [targetDocument]);
  return {
    isLeaf,
    open,
    level,
    buttonSize: 'small',
    isActionsVisible: actions ? isActionsVisible : false,
    components: {
      content: 'div',
      root: 'div',
      expandIcon: 'span',
      actions: 'span',
      subtree: 'span'
    },
    subtree: react_utilities_1.resolveShorthand(subtree, {
      required: Boolean(subtreeChildren),
      defaultProps: {
        children: subtreeChildren,
        ref: react_utilities_3.useMergedRefs(subtreeRef, react_utilities_1.isResolvedShorthand(subtree) ? subtree.ref : undefined)
      }
    }),
    content: react_utilities_1.resolveShorthand(content, {
      required: true,
      defaultProps: {
        children
      }
    }),
    root: react_utilities_1.getNativeElementProps(as, {
      tabIndex: -1,
      ...rest,
      id,
      ref,
      children: null,
      'aria-level': level,
      'aria-expanded': isBranch ? open : undefined,
      role: 'treeitem',
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseOver: actions ? showActions : undefined,
      onFocus: actions ? showActions : undefined,
      onMouseOut: actions ? hideActions : undefined,
      onBlur: actions ? hideActions : undefined
    }),
    expandIcon: react_utilities_1.resolveShorthand(expandIcon, {
      required: isBranch,
      defaultProps: {
        children: React.createElement(react_icons_1.ChevronRight12Regular, {
          style: useTreeItemStyles_1.expandIconInlineStyles[expandIconRotation]
        }),
        'aria-hidden': true,
        ref: react_utilities_3.useMergedRefs(react_utilities_1.isResolvedShorthand(expandIcon) ? expandIcon.ref : undefined, expandIconRef)
      }
    }),
    actions: react_utilities_1.resolveShorthand(actions, {
      defaultProps: {
        ref: react_utilities_3.useMergedRefs(react_utilities_1.isResolvedShorthand(actions) ? actions.ref : undefined, actionsRef)
      }
    })
  };
};
exports.useTreeItem_unstable = useTreeItem_unstable;
//# sourceMappingURL=useTreeItem.js.map