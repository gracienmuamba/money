"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRovingTabIndex = void 0;
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
const React = /*#__PURE__*/require("react");
const useHTMLElementWalker_1 = /*#__PURE__*/require("./useHTMLElementWalker");
/**
 * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex
 */
function useRovingTabIndex(filter) {
  const currentElementRef = React.useRef();
  const [walkerRef, rootRef] = useHTMLElementWalker_1.useHTMLElementWalkerRef(filter);
  const rootRefCallback = element => {
    if (!element) {
      return;
    }
    reset();
  };
  function reset() {
    if (!walkerRef.current) {
      return;
    }
    const walker = walkerRef.current;
    walker.currentElement = walker.root;
    let tabbableChild = walker.firstChild(element => element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
    walker.currentElement = walker.root;
    tabbableChild !== null && tabbableChild !== void 0 ? tabbableChild : tabbableChild = walker.firstChild();
    if (!tabbableChild) {
      if (process.env.NODE_ENV === 'development') {
        // eslint-disable-next-line no-console
        console.warn('useRovingTabIndexes: internal error, no tabbable element was found');
      }
      return;
    }
    tabbableChild.tabIndex = 0;
    currentElementRef.current = tabbableChild;
    let nextElement = null;
    while ((nextElement = walker.nextElement()) && nextElement !== tabbableChild) {
      nextElement.tabIndex = -1;
    }
  }
  function rove(nextElement) {
    if (!currentElementRef.current) {
      return;
    }
    currentElementRef.current.tabIndex = -1;
    nextElement.tabIndex = 0;
    nextElement.focus();
    currentElementRef.current = nextElement;
  }
  return [{
    rove,
    reset
  }, react_utilities_1.useMergedRefs(rootRef, rootRefCallback)];
}
exports.useRovingTabIndex = useRovingTabIndex;
//# sourceMappingURL=useRovingTabIndexes.js.map