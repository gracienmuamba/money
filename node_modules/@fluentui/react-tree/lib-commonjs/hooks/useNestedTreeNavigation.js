"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useNestedTreeNavigation = void 0;
const useHTMLElementWalker_1 = /*#__PURE__*/require("./useHTMLElementWalker");
const nextTypeAheadElement_1 = /*#__PURE__*/require("../utils/nextTypeAheadElement");
const tokens_1 = /*#__PURE__*/require("../utils/tokens");
const treeItemFilter_1 = /*#__PURE__*/require("../utils/treeItemFilter");
const useRovingTabIndexes_1 = /*#__PURE__*/require("./useRovingTabIndexes");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
function useNestedTreeNavigation() {
  const [{
    rove
  }, rovingRootRef] = useRovingTabIndexes_1.useRovingTabIndex(treeItemFilter_1.treeItemFilter);
  const [walkerRef, rootRef] = useHTMLElementWalker_1.useHTMLElementWalkerRef(treeItemFilter_1.treeItemFilter);
  const getNextElement = data => {
    if (!walkerRef.current) {
      return;
    }
    const treeItemWalker = walkerRef.current;
    switch (data.type) {
      case tokens_1.treeDataTypes.click:
        return data.target;
      case tokens_1.treeDataTypes.typeAhead:
        treeItemWalker.currentElement = data.target;
        return nextTypeAheadElement_1.nextTypeAheadElement(treeItemWalker, data.event.key);
      case tokens_1.treeDataTypes.arrowLeft:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.parentElement();
      case tokens_1.treeDataTypes.arrowRight:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.firstChild();
      case tokens_1.treeDataTypes.end:
        treeItemWalker.currentElement = treeItemWalker.root;
        return lastChildRecursive(treeItemWalker);
      case tokens_1.treeDataTypes.home:
        treeItemWalker.currentElement = treeItemWalker.root;
        return treeItemWalker.firstChild();
      case tokens_1.treeDataTypes.arrowDown:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.nextElement();
      case tokens_1.treeDataTypes.arrowUp:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.previousElement();
    }
  };
  function navigate(data) {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement);
    }
  }
  return [navigate, react_utilities_1.useMergedRefs(rootRef, rovingRootRef)];
}
exports.useNestedTreeNavigation = useNestedTreeNavigation;
function lastChildRecursive(walker) {
  let lastElement = null;
  let nextElement = null;
  while (nextElement = walker.lastChild()) {
    lastElement = nextElement;
  }
  return lastElement;
}
//# sourceMappingURL=useNestedTreeNavigation.js.map