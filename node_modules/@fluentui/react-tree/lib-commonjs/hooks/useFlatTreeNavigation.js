"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFlatTreeNavigation = void 0;
const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");
const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");
const nextTypeAheadElement_1 = /*#__PURE__*/require("../utils/nextTypeAheadElement");
const tokens_1 = /*#__PURE__*/require("../utils/tokens");
const treeItemFilter_1 = /*#__PURE__*/require("../utils/treeItemFilter");
const useHTMLElementWalker_1 = /*#__PURE__*/require("./useHTMLElementWalker");
const useRovingTabIndexes_1 = /*#__PURE__*/require("./useRovingTabIndexes");
function useFlatTreeNavigation(flatTree) {
  const {
    targetDocument
  } = react_shared_contexts_1.useFluent_unstable();
  const [treeItemWalkerRef, treeItemWalkerRootRef] = useHTMLElementWalker_1.useHTMLElementWalkerRef(treeItemFilter_1.treeItemFilter);
  const [{
    rove
  }, rovingRootRef] = useRovingTabIndexes_1.useRovingTabIndex(treeItemFilter_1.treeItemFilter);
  function getNextElement(data) {
    if (!targetDocument || !treeItemWalkerRef.current) {
      return null;
    }
    const treeItemWalker = treeItemWalkerRef.current;
    switch (data.type) {
      case tokens_1.treeDataTypes.click:
        return data.target;
      case tokens_1.treeDataTypes.typeAhead:
        treeItemWalker.currentElement = data.target;
        return nextTypeAheadElement_1.nextTypeAheadElement(treeItemWalker, data.event.key);
      case tokens_1.treeDataTypes.arrowLeft:
        return parentElement(flatTree, data.target, targetDocument);
      case tokens_1.treeDataTypes.arrowRight:
        treeItemWalker.currentElement = data.target;
        return firstChild(data.target, treeItemWalker);
      case tokens_1.treeDataTypes.end:
        treeItemWalker.currentElement = treeItemWalker.root;
        return treeItemWalker.lastChild();
      case tokens_1.treeDataTypes.home:
        treeItemWalker.currentElement = treeItemWalker.root;
        return treeItemWalker.firstChild();
      case tokens_1.treeDataTypes.arrowDown:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.nextElement();
      case tokens_1.treeDataTypes.arrowUp:
        treeItemWalker.currentElement = data.target;
        return treeItemWalker.previousElement();
    }
  }
  function navigate(data) {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement);
    }
  }
  return [navigate, react_utilities_1.useMergedRefs(treeItemWalkerRootRef, rovingRootRef)];
}
exports.useFlatTreeNavigation = useFlatTreeNavigation;
function firstChild(target, treeWalker) {
  const nextElement = treeWalker.nextElement();
  if (!nextElement) {
    return null;
  }
  const nextElementAriaPosInSet = nextElement.getAttribute('aria-posinset');
  const nextElementAriaLevel = nextElement.getAttribute('aria-level');
  const targetAriaLevel = target.getAttribute('aria-level');
  if (nextElementAriaPosInSet === '1' && Number(nextElementAriaLevel) === Number(targetAriaLevel) + 1) {
    return nextElement;
  }
  return null;
}
function parentElement(flatTree, target, document) {
  const flatTreeItem = flatTree.itemsPerId.get(target.id);
  if (flatTreeItem && flatTreeItem.parentId) {
    return document.getElementById(flatTreeItem.parentId);
  }
  return null;
}
//# sourceMappingURL=useFlatTreeNavigation.js.map