/// <reference types="react" />

import { ArrowDown } from '@fluentui/keyboard-keys';
import { ArrowLeft } from '@fluentui/keyboard-keys';
import { ArrowRight } from '@fluentui/keyboard-keys';
import { ArrowUp } from '@fluentui/keyboard-keys';
import type { AvatarContextValue } from '@fluentui/react-avatar';
import type { AvatarSize } from '@fluentui/react-avatar';
import type { ButtonContextValue } from '@fluentui/react-button';
import type { ComponentProps } from '@fluentui/react-utilities';
import type { ComponentState } from '@fluentui/react-utilities';
import { ContextSelector } from '@fluentui/react-context-selector';
import { End } from '@fluentui/keyboard-keys';
import { Enter } from '@fluentui/keyboard-keys';
import type { ExtractSlotProps } from '@fluentui/react-utilities';
import { FC } from 'react';
import type { ForwardRefComponent } from '@fluentui/react-utilities';
import { Home } from '@fluentui/keyboard-keys';
import { Provider } from 'react';
import { ProviderProps } from 'react';
import * as React_2 from 'react';
import type { Slot } from '@fluentui/react-utilities';
import type { SlotClassNames } from '@fluentui/react-utilities';

/**
 * Converts a nested structure to a flat one which can be consumed by `useFlatTreeItems`
 */
export declare const flattenTree_unstable: (items: NestedTreeItem[]) => FlatTreeItemProps[];

/**
 * FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 *
 * On simple scenarios it is advised to simply use a nested structure instead.
 */
export declare type FlatTree = {
    /**
     * returns the properties required for the Tree component to work properly.
     * That includes:
     * `openItems`, `onOpenChange`, `onNavigation_unstable` and `ref`
     */
    getTreeProps(): FlatTreeProps;
    /**
     * internal method used to react to an `onNavigation` event.
     * This method ensures proper navigation on keyboard and mouse interaction.
     * In case of virtualization it might be required to cancel default provided `onNavigation`
     * event and then call this method manually.
     *
     * @example
     * ```ts
     * // react-window
     * const handleNavigation = (event, data) => {
     *   event.preventDefault();
     *   const nextItem = tree.getNextNavigableItem(data);
     *   // scroll to item using virtualization scroll mechanism
     *   if (nextItem && !targetDocument.getElementById(nextItem.id)) {
     *     listRef.current.scrollToItem(nextItem.index);
     *   }
     *   // wait for scrolling to happen and then invoke navigate method
     *   requestAnimationFrame(() => {
     *     tree.navigate(data);
     *   });
     * };
     *```
     */
    navigate(data: TreeNavigationData_unstable): void;
    /**
     * returns next item to be focused on a navigation.
     * This method is provided to decouple the element that needs to be focused from
     *  the action of focusing it itself.
     */
    getNextNavigableItem(data: TreeNavigationData_unstable): FlatTreeItem | null;
    /**
     * returns a single flat tree item by id without iterating over the whole collection
     */
    getItem(id: string): FlatTreeItem | null;
    /**
     * returns an iterable containing all visually available flat tree items
     */
    items(): Iterable<FlatTreeItem>;
};

export declare type FlatTreeItem = {
    getTreeItemProps(): Required<Pick<TreeItemProps, 'id' | 'aria-setsize' | 'aria-level' | 'aria-posinset' | 'leaf'>> & TreeItemProps;
    parentId?: string;
    childrenSize: number;
    index: number;
    id: string;
    level: number;
};

export declare type FlatTreeItemProps = Required<Pick<TreeItemProps, 'id'>> & TreeItemProps & {
    parentId?: string;
};

export declare type FlatTreeProps = Required<Pick<TreeProps, 'openItems' | 'onOpenChange' | 'onNavigation_unstable'> & {
    ref: React_2.Ref<HTMLDivElement>;
}>;

declare interface ImmutableSet<Value> {
    /**
     * The number of (unique) elements in a ImmutableSet.
     */
    readonly size: number;
    /**
     * Creates a new ImmutableSet containing all previous element plus the one provided as argument
     * @param value - new value to be included in the new ImmutableSet instance
     */
    add(value: Value): ImmutableSet<Value>;
    /**
     * Returns a reference to ImmutableSet.emptySet
     */
    clear(): ImmutableSet<Value>;
    /**
     * Creates a new ImmutableSet with the original items and removes a specified value from the new ImmutableSet.
     */
    delete(value: Value): ImmutableSet<Value>;
    /**
     * @returns a boolean indicating whether an element with the specified value exists in the ImmutableSet or not.
     */
    has(value: Value): boolean;
    /** Iterates over values in the ImmutableSet. */
    [Symbol.iterator](): IterableIterator<Value>;
}

export declare type NestedTreeItem = Omit<TreeItemProps, 'subtree'> & {
    subtree?: NestedTreeItem[];
};

export declare const renderTree_unstable: (state: TreeState, contextValues: TreeContextValues) => JSX.Element;

/**
 * Render the final JSX of TreeItem
 */
export declare const renderTreeItem_unstable: (state: TreeItemState, contextValues: TreeItemContextValues) => JSX.Element;

/**
 * Render the final JSX of TreeItemLayout
 */
export declare const renderTreeItemLayout_unstable: (state: TreeItemLayoutState) => JSX.Element;

/**
 * Render the final JSX of TreeItemPersonaLayout
 */
export declare const renderTreeItemPersonaLayout_unstable: (state: TreeItemPersonaLayoutState, contextValues: TreeItemPersonaLayoutContextValues) => JSX.Element;

/**
 * A tree view widget presents a hierarchical list.
 * Any item in the hierarchy may have child items,
 * and items that have children may be expanded or collapsed to show or hide the children.
 * For example, in a file system navigator that uses a tree view to display folders and files,
 * an item representing a folder can be expanded to reveal the contents of the folder,
 * which may be files, folders, or both.
 */
export declare const Tree: ForwardRefComponent<TreeProps>;

export declare const treeClassNames: SlotClassNames<TreeSlots>;

export declare type TreeContextValue = {
    level: number;
    appearance: 'subtle' | 'subtle-alpha' | 'transparent';
    size: 'small' | 'medium';
    openItems: ImmutableSet<TreeItemId>;
    /**
     * Requests dialog main component to update it's internal open state
     */
    requestOpenChange(data: TreeOpenChangeData): void;
    requestNavigation(data: TreeNavigationData_unstable): void;
};

declare type TreeContextValues = {
    tree: TreeContextValue;
};

/**
 * TreeItem component - TODO: add more docs
 */
export declare const TreeItem: ForwardRefComponent<TreeItemProps>;

export declare const treeItemClassNames: SlotClassNames<TreeItemSlots>;

declare type TreeItemContextValue = {
    isActionsVisible: boolean;
};

declare type TreeItemContextValues = {
    treeItem: TreeItemContextValue;
    button: ButtonContextValue;
};

declare type TreeItemCSSProperties = React_2.CSSProperties & {
    [treeItemLevelToken]?: string | number;
};

export declare type TreeItemId = string | number;

/**
 * TreeItemLayout component - TODO: add more docs
 */
export declare const TreeItemLayout: ForwardRefComponent<TreeItemLayoutProps>;

export declare const treeItemLayoutClassNames: SlotClassNames<TreeItemLayoutSlots>;

/**
 * TreeItemLayout Props
 */
export declare type TreeItemLayoutProps = ComponentProps<Partial<TreeItemLayoutSlots>>;

export declare type TreeItemLayoutSlots = {
    root: Slot<'div'>;
    /**
     * Icon slot that renders right before main content
     */
    iconBefore?: Slot<'span'>;
    /**
     * Icon slot that renders right after main content
     */
    iconAfter?: Slot<'span'>;
    aside?: Slot<'span'>;
};

/**
 * State used in rendering TreeItemLayout
 */
export declare type TreeItemLayoutState = ComponentState<TreeItemLayoutSlots> & TreeItemContextValue;

export declare const treeItemLevelToken: "--fluent-TreeItem--level";

/**
 * TreeItemPersonaLayout component - TODO: add more docs
 */
export declare const TreeItemPersonaLayout: ForwardRefComponent<TreeItemPersonaLayoutProps>;

export declare const treeItemPersonaLayoutClassNames: SlotClassNames<TreeItemPersonaLayoutSlots>;

declare type TreeItemPersonaLayoutContextValues = {
    avatar: AvatarContextValue;
};

/**
 * TreeItemPersonaLayout Props
 */
export declare type TreeItemPersonaLayoutProps = ComponentProps<Partial<TreeItemPersonaLayoutSlots>>;

export declare type TreeItemPersonaLayoutSlots = {
    root: Slot<'span'>;
    /**
     * Avatar to display.
     */
    media: NonNullable<Slot<'span'>>;
    /**
     * Main text. Children of the root slot are automatically rendered here
     */
    main: Slot<'span'>;
    /**
     * Secondary text that describes or complements the main text
     */
    description?: Slot<'span'>;
    /**
     * aside text that works as extra textual information
     */
    aside?: Slot<'span'>;
    /**
     * A layout wrapper for the main and description slots
     */
    content: Slot<'div'>;
};

/**
 * State used in rendering TreeItemPersonaLayout
 */
export declare type TreeItemPersonaLayoutState = ComponentState<TreeItemPersonaLayoutSlots> & TreeItemContextValue & {
    avatarSize: AvatarSize;
};

/**
 * TreeItem Props
 */
export declare type TreeItemProps = ComponentProps<Partial<TreeItemSlots>> & {
    /**
     * If a TreeItem is a leaf, it'll not present the `expandIcon` slot by default.
     * This attribute is used to force the decision if a TreeItem is a leaf or not. By not providing this property
     * this will be inferred by the presence of a subtree as part of the TreeItem children.
     */
    leaf?: boolean;
};

export declare const TreeItemProvider: React_2.Provider<TreeItemContextValue | undefined>;

export declare type TreeItemSlots = {
    root: Slot<ExtractSlotProps<Slot<'div'> & {
        style?: TreeItemCSSProperties;
    }>>;
    content: NonNullable<Slot<'div'>>;
    subtree?: Slot<'span'>;
    /**
     * Expand icon slot,
     * by default renders a chevron icon to indicate opening and closing
     */
    expandIcon?: Slot<'span'>;
    /**
     * Actions slot that renders on the end of tree item
     * when the item is hovered/focused
     */
    actions?: Slot<'span'>;
};

/**
 * State used in rendering TreeItem
 */
export declare type TreeItemState = ComponentState<TreeItemSlots> & {
    open: boolean;
    isLeaf: boolean;
    level: number;
    /**
     * By design, a button included on the actions slot should be small
     */
    buttonSize: 'small';
    isActionsVisible: boolean;
};

export declare type TreeNavigationData_unstable = {
    event: React_2.MouseEvent<HTMLElement>;
    target: HTMLElement;
    type: 'Click';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: 'TypeAhead';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowRight;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowLeft;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowUp;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowDown;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof Home;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof End;
};

export declare type TreeNavigationEvent_unstable = TreeNavigationData_unstable['event'];

export declare type TreeOpenChangeData = {
    open: boolean;
} & ({
    event: React_2.MouseEvent<HTMLElement>;
    target: HTMLElement;
    type: 'ExpandIconClick';
} | {
    event: React_2.MouseEvent<HTMLElement>;
    target: HTMLElement;
    type: 'Click';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof Enter;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowRight;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowLeft;
});

export declare type TreeOpenChangeEvent = TreeOpenChangeData['event'];

export declare type TreeProps = ComponentProps<TreeSlots> & {
    /**
     * A tree item can have various appearances:
     * - 'subtle' (default): The default tree item styles.
     * - 'subtle-alpha': Minimizes emphasis on hovered or focused states.
     * - 'transparent': Removes background color.
     * @default 'subtle'
     */
    appearance?: 'subtle' | 'subtle-alpha' | 'transparent';
    /**
     * Size of the tree item.
     * @default 'medium'
     */
    size?: 'small' | 'medium';
    /**
     * This refers to a list of ids of opened tree items.
     * Controls the state of the open tree items.
     * These property is ignored for subtrees.
     */
    openItems?: Iterable<TreeItemId>;
    /**
     * This refers to a list of ids of opened tree items.
     * Default value for the uncontrolled state of open tree items.
     * These property is ignored for subtrees.
     */
    defaultOpenItems?: Iterable<TreeItemId>;
    /**
     * Callback fired when the component changes value from open state.
     * These property is ignored for subtrees.
     *
     * @param event - a React's Synthetic event
     * @param data - A data object with relevant information,
     * such as open value and type of interaction that created the event.
     */
    onOpenChange?(event: TreeOpenChangeEvent, data: TreeOpenChangeData): void;
    /**
     * Callback fired when navigation happens inside the component.
     * These property is ignored for subtrees.
     *
     * FIXME: This method is not ideal, as navigation should be handled internally by tabster.
     *
     * @param event - a React's Synthetic event
     * @param data - A data object with relevant information,
     */
    onNavigation_unstable?(event: TreeNavigationEvent_unstable, data: TreeNavigationData_unstable): void;
};

export declare const TreeProvider: Provider<TreeContextValue | undefined> & FC<ProviderProps<TreeContextValue | undefined>>;

export declare type TreeSlots = {
    root: Slot<'div'>;
};

/**
 * State used in rendering Tree
 */
export declare type TreeState = ComponentState<TreeSlots> & TreeContextValue;

/**
 * this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 * On simple scenarios it is advised to simply use a nested structure instead.
 *
 * @param items - a list of tree items
 * @param options - in case control over the internal openItems is required
 */
export declare function useFlatTree_unstable(items: FlatTreeItemProps[], options?: Pick<TreeProps, 'openItems' | 'defaultOpenItems'>): FlatTree;

/**
 * Create the state required to render Tree.
 *
 * The returned state can be modified with hooks such as useTreeStyles_unstable,
 * before being passed to renderTree_unstable.
 *
 * @param props - props from this instance of Tree
 * @param ref - reference to root HTMLElement of Tree
 */
export declare const useTree_unstable: (props: TreeProps, ref: React_2.Ref<HTMLElement>) => TreeState;

export declare const useTreeContext_unstable: <T>(selector: ContextSelector<TreeContextValue, T>) => T;

export declare function useTreeContextValues_unstable(state: TreeState): TreeContextValues;

/**
 * Create the state required to render TreeItem.
 *
 * The returned state can be modified with hooks such as useTreeItemStyles_unstable,
 * before being passed to renderTreeItem_unstable.
 *
 * @param props - props from this instance of TreeItem
 * @param ref - reference to root HTMLElement of TreeItem
 */
export declare const useTreeItem_unstable: (props: TreeItemProps, ref: React_2.Ref<HTMLDivElement>) => TreeItemState;

export declare const useTreeItemContext_unstable: () => TreeItemContextValue;

/**
 * Create the state required to render TreeItemLayout.
 *
 * The returned state can be modified with hooks such as useTreeItemLayoutStyles_unstable,
 * before being passed to renderTreeItemLayout_unstable.
 *
 * @param props - props from this instance of TreeItemLayout
 * @param ref - reference to root HTMLElement of TreeItemLayout
 */
export declare const useTreeItemLayout_unstable: (props: TreeItemLayoutProps, ref: React_2.Ref<HTMLElement>) => TreeItemLayoutState;

/**
 * Apply styling to the TreeItemLayout slots based on the state
 */
export declare const useTreeItemLayoutStyles_unstable: (state: TreeItemLayoutState) => TreeItemLayoutState;

/**
 * Create the state required to render TreeItemPersonaLayout.
 *
 * The returned state can be modified with hooks such as useTreeItemPersonaLayoutStyles_unstable,
 * before being passed to renderTreeItemPersonaLayout_unstable.
 *
 * @param props - props from this instance of TreeItemPersonaLayout
 * @param ref - reference to root HTMLElement of TreeItemPersonaLayout
 */
export declare const useTreeItemPersonaLayout_unstable: (props: TreeItemPersonaLayoutProps, ref: React_2.Ref<HTMLSpanElement>) => TreeItemPersonaLayoutState;

/**
 * Apply styling to the TreeItemPersonaLayout slots based on the state
 */
export declare const useTreeItemPersonaLayoutStyles_unstable: (state: TreeItemPersonaLayoutState) => TreeItemPersonaLayoutState;

/**
 * Apply styling to the TreeItem slots based on the state
 */
export declare const useTreeItemStyles_unstable: (state: TreeItemState) => TreeItemState;

export declare const useTreeStyles_unstable: (state: TreeState) => TreeState;

export { }
