{"version":3,"names":["getParentNode","node","nodeName","parentNode","host","exports","getStyleComputedProperty","nodeType","window","_a","ownerDocument","defaultView","getComputedStyle","getScrollParent","document","body","overflow","overflowX","overflowY","test","hasScrollParent","scrollParentElement"],"sources":["../src/packages/react-components/react-positioning/src/utils/getScrollParent.ts"],"sourcesContent":["/**\n * Returns the parent node or the host of the node argument.\n * @param node - DOM node.\n * @returns - parent DOM node.\n */\nexport const getParentNode = (node: HTMLElement): HTMLElement => {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return node.parentNode || (node as any).host;\n};\n\n/**\n * Returns CSS styles of the given node.\n * @param node - DOM node.\n * @returns - CSS styles.\n */\nconst getStyleComputedProperty = (node: HTMLElement): Partial<CSSStyleDeclaration> => {\n  if (node.nodeType !== 1) {\n    return {};\n  }\n\n  const window = node.ownerDocument?.defaultView;\n  return window!.getComputedStyle(node, null);\n};\n\n/**\n * Returns the first scrollable parent of the given element.\n * @param node - DOM node.\n * @returns - the first scrollable parent.\n */\nexport const getScrollParent = (node: Document | HTMLElement | null): HTMLElement => {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  const parentNode = node && getParentNode(node as HTMLElement);\n  // eslint-disable-next-line\n  if (!parentNode) return document.body;\n\n  switch (parentNode.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return parentNode.ownerDocument!.body;\n    case '#document':\n      return (parentNode as unknown as Document).body;\n  }\n\n  // If any of the overflow props is defined for the node then we return it as the parent\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);\n  if (/(auto|scroll|overlay)/.test(overflow! + overflowY! + overflowX)) {\n    return parentNode;\n  }\n\n  return getScrollParent(parentNode);\n};\n\nexport const hasScrollParent = (node: Document | HTMLElement | null): boolean => {\n  const scrollParentElement: HTMLElement = getScrollParent(node);\n  return scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument?.body : false;\n};\n"],"mappings":";;;;;;AAAA;;;;;AAKO,MAAMA,aAAa,GAAIC,IAAiB,IAAiB;EAC9D,IAAIA,IAAI,CAACC,QAAQ,KAAK,MAAM,EAAE;IAC5B,OAAOD,IAAI;;EAEb;EACA,OAAOA,IAAI,CAACE,UAAU,IAAKF,IAAY,CAACG,IAAI;AAC9C,CAAC;AANYC,OAAA,CAAAL,aAAa,GAAAA,aAAA;AAQ1B;;;;;AAKA,MAAMM,wBAAwB,GAAIL,IAAiB,IAAkC;;EACnF,IAAIA,IAAI,CAACM,QAAQ,KAAK,CAAC,EAAE;IACvB,OAAO,EAAE;;EAGX,MAAMC,MAAM,GAAG,CAAAC,EAAA,GAAAR,IAAI,CAACS,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,WAAW;EAC9C,OAAOH,MAAO,CAACI,gBAAgB,CAACX,IAAI,EAAE,IAAI,CAAC;AAC7C,CAAC;AAED;;;;;AAKO,MAAMY,eAAe,GAAIZ,IAAmC,IAAiB;EAClF;EACA,MAAME,UAAU,GAAGF,IAAI,IAAII,OAAA,CAAAL,aAAa,CAACC,IAAmB,CAAC;EAC7D;EACA,IAAI,CAACE,UAAU,EAAE,OAAOW,QAAQ,CAACC,IAAI;EAErC,QAAQZ,UAAU,CAACD,QAAQ;IACzB,KAAK,MAAM;IACX,KAAK,MAAM;MACT,OAAOC,UAAU,CAACO,aAAc,CAACK,IAAI;IACvC,KAAK,WAAW;MACd,OAAQZ,UAAkC,CAACY,IAAI;EAAC;EAGpD;EACA,MAAM;IAAEC,QAAQ;IAAEC,SAAS;IAAEC;EAAS,CAAE,GAAGZ,wBAAwB,CAACH,UAAU,CAAC;EAC/E,IAAI,uBAAuB,CAACgB,IAAI,CAACH,QAAS,GAAGE,SAAU,GAAGD,SAAS,CAAC,EAAE;IACpE,OAAOd,UAAU;;EAGnB,OAAOE,OAAA,CAAAQ,eAAe,CAACV,UAAU,CAAC;AACpC,CAAC;AArBYE,OAAA,CAAAQ,eAAe,GAAAA,eAAA;AAuBrB,MAAMO,eAAe,GAAInB,IAAmC,IAAa;;EAC9E,MAAMoB,mBAAmB,GAAgBhB,OAAA,CAAAQ,eAAe,CAACZ,IAAI,CAAC;EAC9D,OAAOoB,mBAAmB,GAAGA,mBAAmB,MAAK,CAAAZ,EAAA,GAAAY,mBAAmB,CAACX,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAEM,IAAI,IAAG,KAAK;AACtG,CAAC;AAHYV,OAAA,CAAAe,eAAe,GAAAA,eAAA"}