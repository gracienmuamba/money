{"version":3,"names":["React","require","react_utilities_1","useState","useRef","useIntersectionObserver","callback","options","observer","observerList","setObserverList","observerInit","setObserverInit","useIsomorphicLayoutEffect","current","IntersectionObserver","length","forEach","element","_a","observe","disconnect","exports"],"sources":["../src/packages/react-components/react-virtualizer/src/hooks/useIntersectionObserver.ts"],"sourcesContent":["import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport * as React from 'react';\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-utilities';\n\nconst { useState, useRef } = React;\n\n/**\n * React hook that allows easy usage of the browser API IntersectionObserver within React\n * @param callback - A function called when the percentage of the target element is visible crosses a threshold.\n * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the\n * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is\n * enough to trigger a callback).\n * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to\n * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.\n */\n\nexport const useIntersectionObserver = (\n  callback: IntersectionObserverCallback,\n  options?: IntersectionObserverInit,\n): {\n  setObserverList: Dispatch<SetStateAction<Element[] | undefined>>;\n  setObserverInit: Dispatch<SetStateAction<IntersectionObserverInit | undefined>>;\n  observer: MutableRefObject<IntersectionObserver | undefined>;\n} => {\n  // export const useIntersectionObserver = (\n  //   callback: IntersectionObserverCallback,\n  //   options?: IntersectionObserverInit,\n  // ): [\n  //   Dispatch<SetStateAction<Element[] | undefined>>,\n  //   Dispatch<SetStateAction<IntersectionObserverInit | undefined>>,\n  //   MutableRefObject<IntersectionObserver | undefined>,\n  // ] => {\n  const observer = useRef<IntersectionObserver>();\n  const [observerList, setObserverList] = useState<Element[]>();\n  const [observerInit, setObserverInit] = useState<IntersectionObserverInit | undefined>(options);\n\n  // Observer elements in passed in list and clean up previous list\n  // This effect is only triggered when observerList is updated\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new IntersectionObserver(callback, observerInit);\n\n    // If we have an instance of IO and a list with elements, observer the elements\n    if (observer.current && observerList && observerList.length > 0) {\n      observerList.forEach(element => {\n        observer.current?.observe(element);\n      });\n    }\n\n    // clean up previous elements being listened to\n    return () => {\n      if (observer.current) {\n        observer.current.disconnect();\n      }\n    };\n  }, [observerList, observerInit, callback]);\n\n  return { setObserverList, setObserverInit, observer };\n};\n"],"mappings":";;;;;;AACA,MAAAA,KAAA,gBAAAC,OAAA;AACA,MAAAC,iBAAA,gBAAAD,OAAA;AAEA,MAAM;EAAEE,QAAQ;EAAEC;AAAM,CAAE,GAAGJ,KAAK;AAElC;;;;;;;;;AAUO,MAAMK,uBAAuB,GAAGA,CACrCC,QAAsC,EACtCC,OAAkC,KAKhC;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMC,QAAQ,GAAGJ,MAAM,EAAwB;EAC/C,MAAM,CAACK,YAAY,EAAEC,eAAe,CAAC,GAAGP,QAAQ,EAAa;EAC7D,MAAM,CAACQ,YAAY,EAAEC,eAAe,CAAC,GAAGT,QAAQ,CAAuCI,OAAO,CAAC;EAE/F;EACA;EACAL,iBAAA,CAAAW,yBAAyB,CAAC,MAAK;IAC7BL,QAAQ,CAACM,OAAO,GAAG,IAAIC,oBAAoB,CAACT,QAAQ,EAAEK,YAAY,CAAC;IAEnE;IACA,IAAIH,QAAQ,CAACM,OAAO,IAAIL,YAAY,IAAIA,YAAY,CAACO,MAAM,GAAG,CAAC,EAAE;MAC/DP,YAAY,CAACQ,OAAO,CAACC,OAAO,IAAG;;QAC7B,CAAAC,EAAA,GAAAX,QAAQ,CAACM,OAAO,cAAAK,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAACF,OAAO,CAAC;MACpC,CAAC,CAAC;;IAGJ;IACA,OAAO,MAAK;MACV,IAAIV,QAAQ,CAACM,OAAO,EAAE;QACpBN,QAAQ,CAACM,OAAO,CAACO,UAAU,EAAE;;IAEjC,CAAC;EACH,CAAC,EAAE,CAACZ,YAAY,EAAEE,YAAY,EAAEL,QAAQ,CAAC,CAAC;EAE1C,OAAO;IAAEI,eAAe;IAAEE,eAAe;IAAEJ;EAAQ,CAAE;AACvD,CAAC;AAzCYc,OAAA,CAAAjB,uBAAuB,GAAAA,uBAAA"}