{"version":3,"names":["useIntersectionObserver_1","require","react_1","react_utilities_1","react_dom_1","useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","intersectionObserverRoot","axis","reversed","onUpdateIndex","onCalculateIndex","virtualizerStartIndex","setVirtualizerStartIndex","useState","beforeElementRef","useRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","current","length","index","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","lastItemIndex","remainingItems","newIndex","actualIndex","end","i","setBeforeRef","useCallback","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useEffect","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","resolveShorthand","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","exports"],"sources":["../src/packages/react-components/react-virtualizer/src/components/Virtualizer/useVirtualizer.ts"],"sourcesContent":["import { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport type { ReactNode } from 'react';\nimport { useEffect, useRef, useState, useCallback, useReducer } from 'react';\n\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\n\nexport function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState {\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    intersectionObserverRoot,\n    axis = 'vertical',\n    reversed = false,\n    onUpdateIndex,\n    onCalculateIndex,\n  } = props;\n\n  // Tracks the initial item to start virtualizer at, -1 implies first render cycle\n  const [virtualizerStartIndex, setVirtualizerStartIndex] = useState<number>(-1);\n\n  // Store ref to before padding element\n  const beforeElementRef = useRef<Element | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = useRef<Element | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef<ReactNode[]>(new Array(virtualizerLength));\n\n  // We want to be methodical about updating the render with child reference array\n  const forceUpdate = useReducer(() => ({}), {})[1];\n\n  const horizontal = axis === 'horizontal';\n\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array<number>(numItems);\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n\n  const batchUpdateNewIndex = (index: number) => {\n    // Local updates\n    onUpdateIndex?.(index, virtualizerStartIndex);\n    updateChildRows(index);\n    updateCurrentItemSizes(index);\n\n    // State setters\n    setVirtualizerStartIndex(index);\n  };\n\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      /* Sanity check - do we even need virtualization? */\n      if (virtualizerLength > numItems) {\n        if (virtualizerStartIndex !== 0) {\n          batchUpdateNewIndex(0);\n        }\n        // No-op\n        return;\n      }\n\n      /* IO initiates this function when needed (bookend entering view) */\n      let measurementPos = 0;\n      let bufferCount = bufferItems;\n\n      // Grab latest entry that is intersecting\n      const latestEntry =\n        entries.length === 1\n          ? entries[0]\n          : entries\n              .sort((entry1, entry2) => entry2.time - entry1.time)\n              .find(entry => {\n                return entry.intersectionRatio > 0;\n              });\n\n      if (!latestEntry) {\n        // If we don't find an intersecting area, ignore for now.\n        return;\n      }\n\n      if (latestEntry.target === afterElementRef.current) {\n        // We need to inverse the buffer count\n        bufferCount = virtualizerLength - bufferItems;\n        measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n        if (!horizontal) {\n          if (reversed) {\n            // Scrolling 'up' and hit the after element below\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' and hit the after element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (reversed) {\n            // Scrolling 'left' and hit the after element\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'right' and hit the after element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      } else if (latestEntry.target === beforeElementRef.current) {\n        measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n        if (!horizontal) {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' in reverse order and hit the before element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'left' and hit before element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      }\n\n      if (reversed) {\n        // We're reversed, up is down, left is right, invert the scroll measure.\n        measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n      }\n\n      // For now lets use hardcoded size to assess current element to paginate on\n      const startIndex = getIndexFromScrollPosition(measurementPos);\n      let bufferedIndex = Math.max(startIndex - bufferCount, 0);\n\n      if (onCalculateIndex) {\n        // User has chance to intervene/customize prior to render\n        // They may want to normalize this value.\n        bufferedIndex = onCalculateIndex(bufferedIndex);\n      }\n\n      // Safety limits\n      const maxIndex = Math.max(numItems - virtualizerLength, 0);\n      const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n\n      if (virtualizerStartIndex !== newStartIndex) {\n        // We flush sync this and perform an immediate state update\n        // due to virtualizerStartIndex invalidation.\n        flushSync(() => {\n          batchUpdateNewIndex(newStartIndex);\n        });\n      }\n    },\n    {\n      root: intersectionObserverRoot ? intersectionObserverRoot?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    },\n  );\n\n  const findIndexRecursive = (scrollPos: number, lowIndex: number, highIndex: number): number => {\n    if (lowIndex > highIndex) {\n      // We shouldn't get here - but no-op the index if we do.\n      return virtualizerStartIndex;\n    }\n    const midpoint = Math.floor((lowIndex + highIndex) / 2);\n    const iBefore = Math.max(midpoint - 1, 0);\n    const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n    const indexValue = childProgressiveSizes.current[midpoint];\n    const afterIndexValue = childProgressiveSizes.current[iAfter];\n    const beforeIndexValue = childProgressiveSizes.current[iBefore];\n    if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n      /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n      return midpoint;\n    }\n\n    if (indexValue > scrollPos) {\n      return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n    } else {\n      return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n    }\n  };\n\n  const getIndexFromSizeArray = (scrollPos: number): number => {\n    /* Quick searches our progressive height array */\n    if (\n      scrollPos === 0 ||\n      childProgressiveSizes.current.length === 0 ||\n      scrollPos <= childProgressiveSizes.current[0]\n    ) {\n      // Check start\n      return 0;\n    }\n\n    if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n      // Check end\n      return childProgressiveSizes.current.length - 1;\n    }\n\n    return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n  };\n\n  const getIndexFromScrollPosition = (scrollPos: number) => {\n    if (!getItemSize) {\n      return Math.round(scrollPos / itemSize);\n    }\n\n    return getIndexFromSizeArray(scrollPos);\n  };\n\n  const calculateTotalSize = () => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  };\n\n  const calculateBefore = () => {\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return virtualizerStartIndex * itemSize;\n    }\n\n    if (virtualizerStartIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[virtualizerStartIndex - 1];\n  };\n\n  const calculateAfter = () => {\n    if (numItems === 0) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(virtualizerStartIndex + virtualizerLength, numItems - 1);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex - 1;\n      return remainingItems * itemSize;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex];\n  };\n\n  const updateChildRows = (newIndex: number) => {\n    if (numItems === 0) {\n      /* Nothing to virtualize */\n\n      return [];\n    }\n\n    if (childArray.current.length !== numItems) {\n      childArray.current = new Array(virtualizerLength);\n    }\n    const actualIndex = Math.max(newIndex, 0);\n    const end = Math.min(actualIndex + virtualizerLength, numItems);\n\n    for (let i = actualIndex; i < end; i++) {\n      childArray.current[i - actualIndex] = renderChild(i);\n    }\n  };\n\n  const setBeforeRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const setAfterRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const updateCurrentItemSizes = (newIndex: number) => {\n    if (!getItemSize) {\n      // Static sizes, not required.\n      return;\n    }\n    // We should always call our size function on index change (only for the items that will be rendered)\n    // This ensures we request the latest data for incoming items in case sizing has changed.\n    const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n    const startIndex = Math.max(newIndex, 0);\n\n    let didUpdate = false;\n    for (let i = startIndex; i < endIndex; i++) {\n      const newSize = getItemSize(i);\n      if (newSize !== childSizes.current[i]) {\n        childSizes.current[i] = newSize;\n        didUpdate = true;\n      }\n    }\n\n    if (didUpdate) {\n      // Update our progressive size array\n      for (let i = startIndex; i < numItems; i++) {\n        const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n        childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n      }\n    }\n  };\n\n  // Initialize the size array before first render.\n  const hasInitialized = useRef<boolean>(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (virtualizerStartIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (virtualizerStartIndex >= 0) {\n      updateChildRows(virtualizerStartIndex);\n      forceUpdate();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild]);\n\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n\n  const isFullyInitialized = hasInitialized.current && virtualizerStartIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: childArray.current,\n    before: resolveShorthand(props.before, {\n      required: true,\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n    }),\n    after: resolveShorthand(props.after, {\n      required: true,\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n    }),\n    beforeContainer: resolveShorthand(props.beforeContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    afterContainer: resolveShorthand(props.afterContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex,\n    axis,\n    bufferSize,\n    reversed,\n  };\n}\n"],"mappings":"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"}