define(["require", "exports", "tslib", "@griffel/react", "@fluentui/react-theme", "@fluentui/react-tabster", "../CardPreview/useCardPreviewStyles", "../CardHeader/useCardHeaderStyles", "../CardFooter/useCardFooterStyles"], function (require, exports, tslib_1, react_1, react_theme_1, react_tabster_1, useCardPreviewStyles_1, useCardHeaderStyles_1, useCardFooterStyles_1) {
    "use strict";
    var _a, _b, _c, _d, _e, _f;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCardStyles_unstable = exports.cardCSSVars = exports.cardClassNames = void 0;
    /**
     * Static CSS class names used internally for the component slots.
     */
    exports.cardClassNames = {
        root: 'fui-Card',
        floatingAction: 'fui-Card__floatingAction',
        checkbox: 'fui-Card__checkbox',
    };
    /**
     * CSS variable names used internally for uniform styling in Card.
     */
    exports.cardCSSVars = {
        cardSizeVar: '--fui-Card--size',
        cardBorderRadiusVar: '--fui-Card--border-radius',
    };
    var focusOutlineStyle = {
        outlineRadius: "var(" + exports.cardCSSVars.cardBorderRadiusVar + ")",
        outlineWidth: react_theme_1.tokens.strokeWidthThick,
    };
    var useStyles = react_1.makeStyles({
        root: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, react_1.shorthands.overflow('hidden')), react_1.shorthands.borderRadius("var(" + exports.cardCSSVars.cardBorderRadiusVar + ")")), react_1.shorthands.padding("var(" + exports.cardCSSVars.cardSizeVar + ")")), react_1.shorthands.gap("var(" + exports.cardCSSVars.cardSizeVar + ")")), (_a = { display: 'flex', position: 'relative', boxSizing: 'border-box', color: react_theme_1.tokens.colorNeutralForeground1, 
                // Border setting using after pseudo element to allow CardPreview to render behind it.
                '::after': tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, content: '""', pointerEvents: 'none' }, react_1.shorthands.borderStyle('solid')), react_1.shorthands.borderWidth(react_theme_1.tokens.strokeWidthThin)), react_1.shorthands.borderRadius("var(" + exports.cardCSSVars.cardBorderRadiusVar + ")")) }, _a["> ." + useCardHeaderStyles_1.cardHeaderClassNames.root + ", > ." + useCardFooterStyles_1.cardFooterClassNames.root] = {
            flexShrink: 0,
        }, _a["> :not(." + useCardPreviewStyles_1.cardPreviewClassNames.root + "):not(." + useCardHeaderStyles_1.cardHeaderClassNames.root + "):not(." + useCardFooterStyles_1.cardFooterClassNames.root + ")"] = {
            flexGrow: 1,
        }, _a)), react_tabster_1.createFocusOutlineStyle({
            style: focusOutlineStyle,
            selector: 'focus',
        })),
        selectableFocused: react_tabster_1.createFocusOutlineStyle({
            style: focusOutlineStyle,
            selector: 'focus-within',
        }),
        orientationHorizontal: (_b = {
                flexDirection: 'row',
                alignItems: 'center'
            },
            // Remove vertical padding to keep CardPreview content flush with Card's borders.
            _b["> ." + useCardPreviewStyles_1.cardPreviewClassNames.root] = {
                marginTop: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
                marginBottom: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            // Due to Tabster's "Groupper" focus functionality, hidden elements are injected before and after Card's content.
            // As such, the code below targets a CardPreview, when it's the first element.
            // Since this is on horizontal cards, the left padding is removed to keep the content flush with the border.
            _b["> :not([aria-hidden=\"true\"])." + useCardPreviewStyles_1.cardPreviewClassNames.root + ":first-of-type"] = {
                marginLeft: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            // Due to Tabster's "Groupper" focus functionality, hidden elements are injected before and after Card's content.
            // As such, the code below targets a CardPreview, when it's the last element.
            // Since this is on horizontal cards, the right padding is removed to keep the content flush with the border.
            _b["> :not([aria-hidden=\"true\"])." + useCardPreviewStyles_1.cardPreviewClassNames.root + ":last-of-type"] = {
                marginRight: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            // If the last child is a CardHeader or CardFooter, allow it to grow to fill the available space.
            _b["> ." + useCardHeaderStyles_1.cardHeaderClassNames.root + ":last-of-type, > ." + useCardFooterStyles_1.cardFooterClassNames.root + ":last-of-type"] = {
                flexGrow: 1,
            },
            _b),
        orientationVertical: (_c = {
                flexDirection: 'column'
            },
            // Remove lateral padding to keep CardPreview content flush with Card's borders.
            _c["> ." + useCardPreviewStyles_1.cardPreviewClassNames.root] = {
                marginLeft: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
                marginRight: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            // Due to Tabster's "Groupper" focus functionality, hidden elements are injected before and after Card's content.
            // As such, the code below targets a CardPreview, when it's the first element.
            // Since this is on vertical cards, the top padding is removed to keep the content flush with the border.
            _c["> :not([aria-hidden=\"true\"])." + useCardPreviewStyles_1.cardPreviewClassNames.root + ":first-of-type"] = {
                marginTop: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            _c["> ." + exports.cardClassNames.floatingAction + " + ." + useCardPreviewStyles_1.cardPreviewClassNames.root] = {
                marginTop: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            // Due to Tabster's "Groupper" focus functionality, hidden elements are injected before and after Card's content.
            // As such, the code below targets a CardPreview, when it's the first element.
            // Since this is on vertical cards, the bottom padding is removed to keep the content flush with the border.
            _c["> :not([aria-hidden=\"true\"])." + useCardPreviewStyles_1.cardPreviewClassNames.root + ":last-of-type"] = {
                marginBottom: "calc(var(" + exports.cardCSSVars.cardSizeVar + ") * -1)",
            },
            _c),
        sizeSmall: (_d = {},
            _d[exports.cardCSSVars.cardSizeVar] = '8px',
            _d[exports.cardCSSVars.cardBorderRadiusVar] = react_theme_1.tokens.borderRadiusSmall,
            _d),
        sizeMedium: (_e = {},
            _e[exports.cardCSSVars.cardSizeVar] = '12px',
            _e[exports.cardCSSVars.cardBorderRadiusVar] = react_theme_1.tokens.borderRadiusMedium,
            _e),
        sizeLarge: (_f = {},
            _f[exports.cardCSSVars.cardSizeVar] = '16px',
            _f[exports.cardCSSVars.cardBorderRadiusVar] = react_theme_1.tokens.borderRadiusLarge,
            _f),
        filled: {
            backgroundColor: react_theme_1.tokens.colorNeutralBackground1,
            boxShadow: react_theme_1.tokens.shadow4,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
        },
        filledInteractive: {
            cursor: 'pointer',
            backgroundColor: react_theme_1.tokens.colorNeutralBackground1,
            boxShadow: react_theme_1.tokens.shadow4,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground1Hover,
                boxShadow: react_theme_1.tokens.shadow8,
            },
            ':active': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground1Pressed,
            },
        },
        filledInteractiveSelected: {
            backgroundColor: react_theme_1.tokens.colorNeutralBackground1Selected,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Selected)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground1Selected,
            },
        },
        filledAlternative: {
            backgroundColor: react_theme_1.tokens.colorNeutralBackground2,
            boxShadow: react_theme_1.tokens.shadow4,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
        },
        filledAlternativeInteractive: {
            cursor: 'pointer',
            backgroundColor: react_theme_1.tokens.colorNeutralBackground2,
            boxShadow: react_theme_1.tokens.shadow4,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground2Hover,
                boxShadow: react_theme_1.tokens.shadow8,
            },
            ':active': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground2Pressed,
            },
        },
        filledAlternativeInteractiveSelected: {
            backgroundColor: react_theme_1.tokens.colorNeutralBackground2Selected,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Selected)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorNeutralBackground2Selected,
            },
        },
        outline: {
            backgroundColor: react_theme_1.tokens.colorTransparentBackground,
            boxShadow: 'none',
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1)),
        },
        outlineInteractive: {
            cursor: 'pointer',
            backgroundColor: react_theme_1.tokens.colorTransparentBackground,
            boxShadow: 'none',
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorTransparentBackgroundHover,
                '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Hover)),
            },
            ':active': {
                backgroundColor: react_theme_1.tokens.colorTransparentBackgroundPressed,
                '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Pressed)),
            },
        },
        outlineInteractiveSelected: {
            backgroundColor: react_theme_1.tokens.colorTransparentBackgroundSelected,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Selected)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorTransparentBackgroundSelected,
            },
        },
        subtle: {
            backgroundColor: react_theme_1.tokens.colorSubtleBackground,
            boxShadow: 'none',
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
        },
        subtleInteractive: {
            cursor: 'pointer',
            backgroundColor: react_theme_1.tokens.colorSubtleBackground,
            boxShadow: 'none',
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorTransparentStroke)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorSubtleBackgroundHover,
            },
            ':active': {
                backgroundColor: react_theme_1.tokens.colorSubtleBackgroundPressed,
            },
        },
        subtleInteractiveSelected: {
            backgroundColor: react_theme_1.tokens.colorSubtleBackgroundSelected,
            '::after': tslib_1.__assign({}, react_1.shorthands.borderColor(react_theme_1.tokens.colorNeutralStroke1Selected)),
            ':hover': {
                backgroundColor: react_theme_1.tokens.colorSubtleBackgroundSelected,
            },
        },
        select: {
            position: 'absolute',
            top: '4px',
            right: '4px',
            zIndex: 1,
        },
        hiddenCheckbox: tslib_1.__assign(tslib_1.__assign({}, react_1.shorthands.overflow('hidden')), { width: '1px', height: '1px', position: 'absolute', clip: 'rect(0 0 0 0)', clipPath: 'inset(50%)', whiteSpace: 'nowrap' }),
    });
    /**
     * Apply styling to the Card slots based on the state.
     */
    var useCardStyles_unstable = function (state) {
        var styles = useStyles();
        var orientationMap = {
            horizontal: styles.orientationHorizontal,
            vertical: styles.orientationVertical,
        };
        var sizeMap = {
            small: styles.sizeSmall,
            medium: styles.sizeMedium,
            large: styles.sizeLarge,
        };
        var appearanceMap = {
            filled: styles.filled,
            'filled-alternative': styles.filledAlternative,
            outline: styles.outline,
            subtle: styles.subtle,
        };
        var selectedMap = {
            filled: styles.filledInteractiveSelected,
            'filled-alternative': styles.filledAlternativeInteractiveSelected,
            outline: styles.outlineInteractiveSelected,
            subtle: styles.subtleInteractiveSelected,
        };
        var interactiveMap = {
            filled: styles.filledInteractive,
            'filled-alternative': styles.filledAlternativeInteractive,
            outline: styles.outlineInteractive,
            subtle: styles.subtleInteractive,
        };
        state.root.className = react_1.mergeClasses(exports.cardClassNames.root, styles.root, orientationMap[state.orientation], sizeMap[state.size], appearanceMap[state.appearance], (state.interactive || state.selectable) && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], state.selectFocused && styles.selectableFocused, state.root.className);
        if (state.floatingAction) {
            state.floatingAction.className = react_1.mergeClasses(exports.cardClassNames.floatingAction, styles.select, state.floatingAction.className);
        }
        if (state.checkbox) {
            state.checkbox.className = react_1.mergeClasses(exports.cardClassNames.checkbox, styles.hiddenCheckbox, state.checkbox.className);
        }
        return state;
    };
    exports.useCardStyles_unstable = useCardStyles_unstable;
});
//# sourceMappingURL=useCardStyles.js.map