define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/keyboard-keys", "@fluentui/react-tabster"], function (require, exports, tslib_1, React, react_utilities_1, keyboard_keys_1, react_tabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCardSelectable = void 0;
    /**
     * @internal
     *
     * Create the state related to selectable cards.
     *
     * This internal hook controls all the logic for selectable cards and is
     * intended to be used alongside with useCard_unstable.
     *
     * @param props - props from this instance of Card
     * @param a11yProps - accessibility props shared between elements of the card
     * @param ref - reference to the root element of Card
     */
    var useCardSelectable = function (props, _a, cardRef) {
        var referenceLabel = _a.referenceLabel, referenceId = _a.referenceId;
        var _b = props.checkbox, checkbox = _b === void 0 ? {} : _b, selected = props.selected, defaultSelected = props.defaultSelected, onSelectionChange = props.onSelectionChange, floatingAction = props.floatingAction, onClick = props.onClick, onKeyDown = props.onKeyDown;
        var findAllFocusable = react_tabster_1.useFocusFinders().findAllFocusable;
        var checkboxRef = React.useRef(null);
        var isSelectable = [selected, defaultSelected, onSelectionChange].some(function (prop) { return typeof prop !== 'undefined'; });
        var _c = React.useState(false), isCardSelected = _c[0], setIsCardSelected = _c[1];
        var _d = React.useState(false), isSelectFocused = _d[0], setIsSelectFocused = _d[1];
        var shouldRestrictTriggerAction = React.useCallback(function (event) {
            if (!cardRef.current) {
                return false;
            }
            var focusableElements = findAllFocusable(cardRef.current);
            var target = event.target;
            var isElementInFocusableGroup = focusableElements.some(function (element) { return element.contains(target); });
            var isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
            return isElementInFocusableGroup && !isCheckboxSlot;
        }, [cardRef, findAllFocusable]);
        var onChangeHandler = React.useCallback(function (event) {
            if (shouldRestrictTriggerAction(event)) {
                return;
            }
            var newCheckedValue = !isCardSelected;
            setIsCardSelected(newCheckedValue);
            if (onSelectionChange) {
                onSelectionChange(event, { selected: newCheckedValue });
            }
        }, [onSelectionChange, isCardSelected, shouldRestrictTriggerAction]);
        var onKeyDownHandler = React.useCallback(function (event) {
            if ([keyboard_keys_1.Enter].includes(event.key)) {
                event.preventDefault();
                onChangeHandler(event);
            }
        }, [onChangeHandler]);
        var checkboxSlot = React.useMemo(function () {
            if (!isSelectable || floatingAction) {
                return;
            }
            var selectableCheckboxProps = {};
            if (referenceId) {
                selectableCheckboxProps['aria-labelledby'] = referenceId;
            }
            else if (referenceLabel) {
                selectableCheckboxProps['aria-label'] = referenceLabel;
            }
            return react_utilities_1.resolveShorthand(checkbox, {
                defaultProps: tslib_1.__assign({ ref: checkboxRef, type: 'checkbox', checked: isCardSelected, onChange: function (event) { return onChangeHandler(event); }, onFocus: function () { return setIsSelectFocused(true); }, onBlur: function () { return setIsSelectFocused(false); } }, selectableCheckboxProps),
            });
        }, [checkbox, floatingAction, isCardSelected, isSelectable, onChangeHandler, referenceId, referenceLabel]);
        var floatingActionSlot = React.useMemo(function () {
            if (!floatingAction) {
                return;
            }
            return react_utilities_1.resolveShorthand(floatingAction, {
                defaultProps: {
                    ref: checkboxRef,
                },
            });
        }, [floatingAction]);
        var selectableCardProps = React.useMemo(function () {
            if (!isSelectable) {
                return null;
            }
            return {
                onClick: react_utilities_1.mergeCallbacks(onClick, onChangeHandler),
                onKeyDown: react_utilities_1.mergeCallbacks(onKeyDown, onKeyDownHandler),
            };
        }, [isSelectable, onChangeHandler, onClick, onKeyDown, onKeyDownHandler]);
        React.useEffect(function () { return setIsCardSelected(Boolean(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : selected)); }, [defaultSelected, selected, setIsCardSelected]);
        return {
            selected: isCardSelected,
            selectable: isSelectable,
            selectFocused: isSelectFocused,
            selectableCardProps: selectableCardProps,
            checkboxSlot: checkboxSlot,
            floatingActionSlot: floatingActionSlot,
        };
    };
    exports.useCardSelectable = useCardSelectable;
});
//# sourceMappingURL=useCardSelectable.js.map