{"ast":null,"code":"import { __assign } from \"tslib\";\nexport var InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0,\n\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1,\n\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2\n};\nvar STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\n\nvar REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\nvar _global = {}; // Grab window.\n\ntry {\n  _global = window || {};\n} catch (_a) {\n  /* leave as blank object */\n}\n\nvar _stylesheet;\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\n\n\nvar Stylesheet =\n/** @class */\nfunction () {\n  function Stylesheet(config, serializedStylesheet) {\n    var _a, _b, _c, _d, _e, _f;\n\n    this._rules = [];\n    this._preservedRules = [];\n    this._counter = 0;\n    this._keyToClassName = {};\n    this._onInsertRuleCallbacks = [];\n    this._onResetCallbacks = [];\n    this._classNameToArgs = {};\n    this._config = __assign({\n      // If there is no document we won't have an element to inject into.\n      injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined\n    }, config);\n    this._classNameToArgs = (_a = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a !== void 0 ? _a : this._classNameToArgs;\n    this._counter = (_b = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b !== void 0 ? _b : this._counter;\n    this._keyToClassName = (_d = (_c = this._config.classNameCache) !== null && _c !== void 0 ? _c : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d !== void 0 ? _d : this._keyToClassName;\n    this._preservedRules = (_e = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e !== void 0 ? _e : this._preservedRules;\n    this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;\n  }\n  /**\n   * Gets the singleton instance.\n   */\n\n\n  Stylesheet.getInstance = function () {\n    _stylesheet = _global[STYLESHEET_SETTING];\n\n    if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {\n      var fabricConfig = (_global === null || _global === void 0 ? void 0 : _global.FabricConfig) || {};\n      var stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      _stylesheet = stylesheet;\n      _global[STYLESHEET_SETTING] = stylesheet;\n    }\n\n    return _stylesheet;\n  };\n  /**\n   * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n   * @returns string representation of `ISerializedStylesheet` interface.\n   */\n\n\n  Stylesheet.prototype.serialize = function () {\n    return JSON.stringify({\n      classNameToArgs: this._classNameToArgs,\n      counter: this._counter,\n      keyToClassName: this._keyToClassName,\n      preservedRules: this._preservedRules,\n      rules: this._rules\n    });\n  };\n  /**\n   * Configures the stylesheet.\n   */\n\n\n  Stylesheet.prototype.setConfig = function (config) {\n    this._config = __assign(__assign({}, this._config), config);\n  };\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   * @returns function which when called un-registers provided callback.\n   */\n\n\n  Stylesheet.prototype.onReset = function (callback) {\n    var _this = this;\n\n    this._onResetCallbacks.push(callback);\n\n    return function () {\n      _this._onResetCallbacks = _this._onResetCallbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    };\n  };\n  /**\n   * Configures an insert rule callback.\n   *\n   * @param callback - A callback which will be called when a rule is inserted.\n   * @returns function which when called un-registers provided callback.\n   */\n\n\n  Stylesheet.prototype.onInsertRule = function (callback) {\n    var _this = this;\n\n    this._onInsertRuleCallbacks.push(callback);\n\n    return function () {\n      _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    };\n  };\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n\n\n  Stylesheet.prototype.getClassName = function (displayName) {\n    var namespace = this._config.namespace;\n    var prefix = displayName || this._config.defaultPrefix;\n    return \"\" + (namespace ? namespace + '-' : '') + prefix + \"-\" + this._counter++;\n  };\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n\n\n  Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {\n    this._keyToClassName[key] = className;\n    this._classNameToArgs[className] = {\n      args: args,\n      rules: rules\n    };\n  };\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n\n\n  Stylesheet.prototype.classNameFromKey = function (key) {\n    return this._keyToClassName[key];\n  };\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n\n\n  Stylesheet.prototype.getClassNameCache = function () {\n    return this._keyToClassName;\n  };\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n\n\n  Stylesheet.prototype.argsFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.args;\n  };\n  /**\n   * Gets the rules associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n\n\n  Stylesheet.prototype.insertedRulesFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.rules;\n  };\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n\n\n  Stylesheet.prototype.insertRule = function (rule, preserve) {\n    var injectionMode = this._config.injectionMode;\n    var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n\n    if (element) {\n      switch (injectionMode) {\n        case InjectionMode.insertNode:\n          var sheet = element.sheet;\n\n          try {\n            sheet.insertRule(rule, sheet.cssRules.length);\n          } catch (e) {// The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n            // which could be slower and bulkier.\n          }\n\n          break;\n\n        case InjectionMode.appendChild:\n          element.appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    } // eslint-disable-next-line deprecation/deprecation\n\n\n    if (this._config.onInsertRule) {\n      // eslint-disable-next-line deprecation/deprecation\n      this._config.onInsertRule(rule);\n    }\n\n    this._onInsertRuleCallbacks.forEach(function (callback) {\n      return callback();\n    });\n  };\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n\n\n  Stylesheet.prototype.getRules = function (includePreservedRules) {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n  };\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n\n\n  Stylesheet.prototype.reset = function () {\n    this._rules = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n\n    this._onResetCallbacks.forEach(function (callback) {\n      return callback();\n    });\n  }; // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n\n\n  Stylesheet.prototype.resetKeys = function () {\n    this._keyToClassName = {};\n  };\n\n  Stylesheet.prototype._getStyleElement = function () {\n    var _this = this;\n\n    if (!this._styleElement && typeof document !== 'undefined') {\n      this._styleElement = this._createStyleElement();\n\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        window.requestAnimationFrame(function () {\n          _this._styleElement = undefined;\n        });\n      }\n    }\n\n    return this._styleElement;\n  };\n\n  Stylesheet.prototype._createStyleElement = function () {\n    var head = document.head;\n    var styleElement = document.createElement('style');\n    var nodeToInsertBefore = null;\n    styleElement.setAttribute('data-merge-styles', 'true');\n    var cspSettings = this._config.cspSettings;\n\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n    } else {\n      var placeholderStyleTag = this._findPlaceholderStyleTag();\n\n      if (placeholderStyleTag) {\n        nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n      } else {\n        nodeToInsertBefore = head.childNodes[0];\n      }\n    }\n\n    head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n    this._lastStyleElement = styleElement;\n    return styleElement;\n  };\n\n  Stylesheet.prototype._findPlaceholderStyleTag = function () {\n    var head = document.head;\n\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n\n    return null;\n  };\n\n  return Stylesheet;\n}();\n\nexport { Stylesheet };","map":{"version":3,"sources":["Stylesheet.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyle } from './IStyle';\n\nexport const InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0 as 0,\n\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1 as 1,\n\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2 as 2,\n};\n\nexport type InjectionMode = typeof InjectionMode[keyof typeof InjectionMode];\n\n/**\n * CSP settings for the stylesheet\n */\nexport interface ICSPSettings {\n  /**\n   * Nonce to inject into script tag\n   */\n  nonce?: string;\n}\n\n/**\n * Stylesheet config.\n *\n * @public\n */\nexport interface IStyleSheetConfig {\n  /**\n   * Injection mode for how rules are inserted.\n   */\n  injectionMode?: InjectionMode;\n\n  /**\n   * Default 'displayName' to use for a className.\n   * @defaultvalue 'css'\n   */\n  defaultPrefix?: string;\n\n  /**\n   * Defines the default direction of rules for auto-rtlifying things.\n   * While typically this is represented as a DIR attribute in the markup,\n   * the DIR is not enough to control whether padding goes on the left or\n   * right. Use this to set the default direction when rules are registered.\n   */\n  rtl?: boolean;\n\n  /**\n   * Default 'namespace' to attach before the className.\n   */\n  namespace?: string;\n\n  /**\n   * CSP settings\n   */\n  cspSettings?: ICSPSettings;\n\n  /**\n   * Callback executed when a rule is inserted.\n   * @deprecated Use `Stylesheet.onInsertRule` instead.\n   */\n  onInsertRule?: (rule: string) => void;\n\n  /**\n   * Initial value for classnames cache. Key is serialized css rules associated with a classname.\n   */\n  classNameCache?: { [key: string]: string };\n}\n\n/**\n * Representation of Stylesheet used for rehydration.\n */\nexport interface ISerializedStylesheet {\n  classNameToArgs: Stylesheet['_classNameToArgs'];\n  counter: Stylesheet['_counter'];\n  keyToClassName: Stylesheet['_keyToClassName'];\n  preservedRules: Stylesheet['_preservedRules'];\n  rules: Stylesheet['_rules'];\n}\n\nconst STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nconst REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\n\nlet _global: (Window | {}) & {\n  [STYLESHEET_SETTING]?: Stylesheet;\n  FabricConfig?: {\n    mergeStyles?: IStyleSheetConfig;\n    serializedStylesheet?: ISerializedStylesheet;\n  };\n} = {};\n\n// Grab window.\ntry {\n  _global = window || {};\n} catch {\n  /* leave as blank object */\n}\n\nlet _stylesheet: Stylesheet | undefined;\n\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nexport class Stylesheet {\n  private _lastStyleElement?: HTMLStyleElement;\n  private _styleElement?: HTMLStyleElement;\n  private _rules: string[] = [];\n  private _preservedRules: string[] = [];\n  private _config: IStyleSheetConfig;\n  private _counter = 0;\n  private _keyToClassName: { [key: string]: string } = {};\n  private _onInsertRuleCallbacks: Function[] = [];\n  private _onResetCallbacks: Function[] = [];\n  private _classNameToArgs: { [key: string]: { args: any; rules: string[] } } = {};\n\n  /**\n   * Gets the singleton instance.\n   */\n  public static getInstance(): Stylesheet {\n    _stylesheet = _global[STYLESHEET_SETTING] as Stylesheet;\n\n    if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n      const fabricConfig = _global?.FabricConfig || {};\n\n      const stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      _stylesheet = stylesheet;\n      _global[STYLESHEET_SETTING] = stylesheet;\n    }\n\n    return _stylesheet;\n  }\n\n  constructor(config?: IStyleSheetConfig, serializedStylesheet?: ISerializedStylesheet) {\n    this._config = {\n      // If there is no document we won't have an element to inject into.\n      injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined,\n      ...config,\n    };\n\n    this._classNameToArgs = serializedStylesheet?.classNameToArgs ?? this._classNameToArgs;\n    this._counter = serializedStylesheet?.counter ?? this._counter;\n    this._keyToClassName = this._config.classNameCache ?? serializedStylesheet?.keyToClassName ?? this._keyToClassName;\n    this._preservedRules = serializedStylesheet?.preservedRules ?? this._preservedRules;\n    this._rules = serializedStylesheet?.rules ?? this._rules;\n  }\n\n  /**\n   * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n   * @returns string representation of `ISerializedStylesheet` interface.\n   */\n  public serialize(): string {\n    return JSON.stringify({\n      classNameToArgs: this._classNameToArgs,\n      counter: this._counter,\n      keyToClassName: this._keyToClassName,\n      preservedRules: this._preservedRules,\n      rules: this._rules,\n    });\n  }\n\n  /**\n   * Configures the stylesheet.\n   */\n  public setConfig(config?: IStyleSheetConfig): void {\n    this._config = {\n      ...this._config,\n      ...config,\n    };\n  }\n\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onReset(callback: Function): Function {\n    this._onResetCallbacks.push(callback);\n\n    return () => {\n      this._onResetCallbacks = this._onResetCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Configures an insert rule callback.\n   *\n   * @param callback - A callback which will be called when a rule is inserted.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onInsertRule(callback: Function): Function {\n    this._onInsertRuleCallbacks.push(callback);\n\n    return () => {\n      this._onInsertRuleCallbacks = this._onInsertRuleCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  public getClassName(displayName?: string): string {\n    const { namespace } = this._config;\n    const prefix = displayName || this._config.defaultPrefix;\n\n    return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;\n  }\n\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  public cacheClassName(className: string, key: string, args: IStyle[], rules: string[]): void {\n    this._keyToClassName[key] = className;\n    this._classNameToArgs[className] = {\n      args,\n      rules,\n    };\n  }\n\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  public classNameFromKey(key: string): string | undefined {\n    return this._keyToClassName[key];\n  }\n\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  public getClassNameCache(): { [key: string]: string } {\n    return this._keyToClassName;\n  }\n\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public argsFromClassName(className: string): IStyle[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.args;\n  }\n\n  /**\n   * Gets the rules associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public insertedRulesFromClassName(className: string): string[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.rules;\n  }\n\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  public insertRule(rule: string, preserve?: boolean): void {\n    const { injectionMode } = this._config;\n    const element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n\n    if (element) {\n      switch (injectionMode) {\n        case InjectionMode.insertNode:\n          const { sheet } = element!;\n\n          try {\n            (sheet as CSSStyleSheet).insertRule(rule, (sheet as CSSStyleSheet).cssRules.length);\n          } catch (e) {\n            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n            // which could be slower and bulkier.\n          }\n          break;\n\n        case InjectionMode.appendChild:\n          element.appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._config.onInsertRule) {\n      // eslint-disable-next-line deprecation/deprecation\n      this._config.onInsertRule(rule);\n    }\n\n    this._onInsertRuleCallbacks.forEach(callback => callback());\n  }\n\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  public getRules(includePreservedRules?: boolean): string {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n  }\n\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  public reset(): void {\n    this._rules = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n\n    this._onResetCallbacks.forEach(callback => callback());\n  }\n\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  public resetKeys(): void {\n    this._keyToClassName = {};\n  }\n\n  private _getStyleElement(): HTMLStyleElement | undefined {\n    if (!this._styleElement && typeof document !== 'undefined') {\n      this._styleElement = this._createStyleElement();\n\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        window.requestAnimationFrame(() => {\n          this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  }\n\n  private _createStyleElement(): HTMLStyleElement {\n    const head: HTMLHeadElement = document.head;\n    const styleElement = document.createElement('style');\n    let nodeToInsertBefore: Node | null = null;\n\n    styleElement.setAttribute('data-merge-styles', 'true');\n\n    const { cspSettings } = this._config;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n    } else {\n      const placeholderStyleTag: Element | null = this._findPlaceholderStyleTag();\n\n      if (placeholderStyleTag) {\n        nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n      } else {\n        nodeToInsertBefore = head.childNodes[0];\n      }\n    }\n\n    head!.insertBefore(styleElement, head!.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n    this._lastStyleElement = styleElement;\n\n    return styleElement;\n  }\n\n  private _findPlaceholderStyleTag(): Element | null {\n    const head: HTMLHeadElement = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}